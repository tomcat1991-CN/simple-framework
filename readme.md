一 init
    1.创建maven工程,引入依赖
    2.编写servlet类,以及jsp文件
    3.运行访问:http://localhost:8080/simple-framework/hello

二 泛型是编译器的约束,编译后会擦除泛型信息
    证明:编译泛型类查看.class文件会发现是没有泛型的
    泛型不支持继承:
    解决:
    com.demo.demo.generic.GenericDemo.main
        1.使用通配符,不指定具体类型,使用时进行强转,这样会使得泛型检查失去意义,和泛型设计初衷是相悖的
        2.给泛型加上边界   <? extends E>   
        3.给泛型加下边界  泛型实参的子类必须是E  ->从避免运行时 参数类型转换异常的角度讲: 这种方式是相较上面两种最安全的

三 工厂模式
    1.简单工厂:
        提供统一的工厂类实现工厂抽象接口,根据客户端指定类型,判断创建所需的类型
        缺点:每次新增需求,都需要在工厂实现类新增代码,违背了开闭原则
        com.demo.pattern.simple.MouseFactory
    2.工厂模式
        将工厂抽象出来:com.demo.pattern.method.MouseFactory
        当需要新的类类型,只需新增工厂实现类,不影响之前代码
        缺点:添加新产品时时,还需添加徐其数量相对的工厂实现了类,'拖家带口',增加了系统的复杂度,代码臃肿
             只支持同一类产品的创建
    3.抽象工厂
        com.demo.pattern.abstractf.ComputerFactory
        提供一个创建一系列相关或相互依赖对象的接口
            抽象工厂模式侧重的是同一产品族->同时定义多个抽象
            工厂方法更加侧重同一产品等级
        解决了工会模式只支持生产一种产品的弊端
            新增一个产品族时,只需要增加一个新的具体工厂,不需要修改代码
            
        缺点
            更多的类型加入抽象工厂时,所有的实现都需要修改 --违背开闭原则
    4. spring的解决方案:
        结合了工厂模式和反射机制的spring-ioc容器值得借鉴
四 反射机制  --java.lang.reflect
    允许程序在运行时进行自我检查,并对内部成员进行操作
    作用:
        在运行时判断任意一个对象所属的类
        在运行时获取类的对象
        在运行时访问java对象的属性,方法,构造方法等
    Class类:
        用来表示运行时类型信息的对应类
            每个类都有唯一一个与之对应的Class对象
            Class类为类类型,而Class对象为类类型对象
    Class类的特点:
        也是类的一种,class则是关键字(用来声明类)
        Class类只有一个私有的构造函数,只有JVM能够创建Class类的实例
        JVM中只有唯一一个和类相对应的Class对象来描述其类型信息(包名+类名+同一个类加载器创建出来的)
        @see java.lang.Class
    获取Class对象的三种方式
        Objec->getClass()  --实例方法
        任何数据类型(包括基本数据类型)都有一个'静态'的class属性  --静态方法
        通过Class类的静态方法: forName(String className)   --常用
    Class对象就像一面镜子,透过这面镜子可以看到类的结构
    如何获取类的